# 1.Реализовать алгоритм сортировки выбором. Алгоритм состоит из следующих шагов:
# найти наименьший элемент в массиве
# поменять местами его и первый элемент в массиве
# найти следующий наименьший элемент в массиве
# и поменять местами его и второй элемент массива
# продолжать это пока весь массив не будет отсортирован
# arr = [0,3,24,2,3,7]
# // здесь реализованный алгоритм
# // на выходе должен получиться список, содержащий [0, 2, 3, 3, 7, 24]

arr = [0, 3, 24, 2, 3, 7]
print(f'Исходный: {arr}')
arr.sort()
print(f'Отсортированный: {arr}')

# 2.Написать и вызвать функцию, возвращающую первый повторившийся символ в переданном списке. Например,
# для  списка [2, 3, 4, 5, 3, 2] функция должна вернуть 3.

num = [2, 3, 4, 5, 3, 2]
dup = [x for i, x in enumerate(num) if i != num.index(x)]
print(dup[:1])

#3.Найти и заменить некие шаблоны в строке: есть строка с определенного вида форматированием, необходимо
# заменить в этой строке все вхождения шаблонов на их значение из словаря.

t_str = 'На каникулы в деревню Машенька к бабуле едет.'
print(f'Исходная строка : {str(t_str)}')
dic = {"деревню": "Сочи", "Машенька": "Дашенька и Анечка", "едет.": "едут."}
tem = t_str.split()
res = []
for wrd in tem:
    res.append(dic.get(wrd, wrd))
res = ' '.join(res)
print("Замененные Строки : " + str(res))

#4.Есть список списков (матрица). Каждый внутренний список – это строка матрицы. Необходимо реализовать функцию,
# которая удаляет столбец, который содержит заданную цифру.

matrix = [
     [10, 20, 30],
     [40, 50, 60],
     [70, 80, 90],
]
print(matrix)

k = int(input("Какой столбец удалить ?"))
for i in range(0, len(matrix)) : del matrix[i][k]
for i in range(0, len(matrix)) : print(matrix[i])

#5.Реализовать функциональность, которая бы “сворачивала” и “разворачивала” символы табуляции в файле.
# То есть, на вход передается файл, необходимо заменить все символы табуляции на четыре пробела,
# либо же заменить все комбинации из четырех символов пробела на символ табуляции
# (в зависимости от опции, указанной пользователем).






